name: Create Release

on:
  workflow_run:
    workflows: ["Build Windows Executable"]
    types:
      - completed
    branches:
      - main

permissions:
  contents: write

jobs:
  release:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download artifacts
        id: download_artifacts
        uses: actions/github-script@v7
        with:
          script: |
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }}
            })
            
            // Download executable
            const execArtifact = artifacts.data.artifacts.find(artifact => artifact.name === "bustle-windows")
            if (execArtifact) {
              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: execArtifact.id,
                archive_format: 'zip'
              })
              const fs = require('fs')
              fs.writeFileSync('bustle-windows.zip', Buffer.from(download.data))
            } else {
              core.warning('No executable artifact found')
            }
            
            // Download installer
            const installerArtifact = artifacts.data.artifacts.find(artifact => artifact.name === "bustle-installer")
            if (installerArtifact) {
              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: installerArtifact.id,
                archive_format: 'zip'
              })
              const fs = require('fs')
              fs.writeFileSync('bustle-installer.zip', Buffer.from(download.data))
            } else {
              core.warning('No installer artifact found')
            }
            
            // Download compressed executable
            const compressedArtifact = artifacts.data.artifacts.find(artifact => artifact.name === "bustle-windows-zip")
            if (compressedArtifact) {
              const download = await github.rest.actions.downloadArtifact({
                owner: context.repo.owner,
                repo: context.repo.repo,
                artifact_id: compressedArtifact.id,
                archive_format: 'zip'
              })
              const fs = require('fs')
              fs.writeFileSync('bustle-windows-compressed.zip', Buffer.from(download.data))
            } else {
              core.warning('No compressed executable artifact found')
            }
            
            // Get workflow run info to check if it was triggered by a tag
            const workflowRun = await github.rest.actions.getWorkflowRun({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: ${{ github.event.workflow_run.id }}
            });
            
            // Check if the workflow was triggered by a tag
            const ref = workflowRun.data.head_branch;
            const isTag = workflowRun.data.head_commit.id !== workflowRun.data.head_sha;
            
            core.exportVariable('IS_TAG', isTag ? 'true' : 'false');
            core.exportVariable('REF_NAME', ref);
            
            return { isTag, ref };
      
      - name: Extract artifacts
        run: |
          mkdir -p artifacts
          unzip -o bustle-windows.zip -d artifacts/ || echo "Failed to extract executable"
          unzip -o bustle-installer.zip -d artifacts/ || echo "Failed to extract installer"
          unzip -o bustle-windows-compressed.zip -d artifacts/ || echo "Failed to extract compressed executable"
      
      - name: Get version info
        id: version
        run: |
          # Get package.json version
          PACKAGE_VERSION=$(node -e "console.log(require('./package.json').version)")
          
          if [[ "$IS_TAG" == "true" ]]; then
            echo "is_tag=true" >> $GITHUB_OUTPUT
            echo "version=$REF_NAME" >> $GITHUB_OUTPUT
            echo "release_name=Release $REF_NAME" >> $GITHUB_OUTPUT
          else
            echo "is_tag=false" >> $GITHUB_OUTPUT
            echo "version=latest" >> $GITHUB_OUTPUT
            echo "release_name=Development Build $PACKAGE_VERSION ($(date +'%Y-%m-%d %H:%M:%S'))" >> $GITHUB_OUTPUT
          fi
      
      - name: Create or Update Release
        id: create_release
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const { version, is_tag, release_name } = process.env;
            
            // For tag-based releases, create a new release with the tag
            if (is_tag === 'true') {
              const release = await github.rest.repos.createRelease({
                owner: context.repo.owner,
                repo: context.repo.repo,
                tag_name: version,
                name: release_name,
                draft: false,
                prerelease: false,
                generate_release_notes: true
              });
              
              // Upload assets to the release
              await uploadAssets(release.data.id);
              return release.data;
            }
            
            // For non-tag builds, find or create the "latest" release
            try {
              // Try to find an existing "latest" release
              const releases = await github.rest.repos.listReleases({
                owner: context.repo.owner,
                repo: context.repo.repo
              });
              
              const latestRelease = releases.data.find(r => r.tag_name === 'latest');
              
              if (latestRelease) {
                // Update existing release
                const updatedRelease = await github.rest.repos.updateRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: latestRelease.id,
                  name: release_name,
                  prerelease: true,
                  draft: false
                });
                
                // Delete existing assets
                const assets = await github.rest.repos.listReleaseAssets({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: latestRelease.id
                });
                
                for (const asset of assets.data) {
                  await github.rest.repos.deleteReleaseAsset({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    asset_id: asset.id
                  });
                }
                
                // Upload new assets
                await uploadAssets(updatedRelease.data.id);
                return updatedRelease.data;
              } else {
                // Create new "latest" release
                const newRelease = await github.rest.repos.createRelease({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  tag_name: 'latest',
                  name: release_name,
                  draft: false,
                  prerelease: true,
                  generate_release_notes: true
                });
                
                // Upload assets
                await uploadAssets(newRelease.data.id);
                return newRelease.data;
              }
            } catch (error) {
              core.setFailed(`Failed to create or update release: ${error.message}`);
              throw error;
            }
            
            // Helper function to upload assets to a release
            async function uploadAssets(releaseId) {
              const files = [
                { path: 'artifacts/bustle.exe', name: 'bustle.exe', contentType: 'application/octet-stream' },
                { path: 'artifacts/BustleInstaller.exe', name: 'BustleInstaller.exe', contentType: 'application/octet-stream' },
                { path: 'artifacts/bustle.zip', name: 'bustle.zip', contentType: 'application/zip' }
              ];
              
              for (const file of files) {
                if (!fs.existsSync(file.path)) {
                  core.warning(`File ${file.path} does not exist, skipping upload`);
                  continue;
                }
                
                const fileData = fs.readFileSync(file.path);
                
                await github.rest.repos.uploadReleaseAsset({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  release_id: releaseId,
                  name: file.name,
                  data: fileData,
                  headers: {
                    'content-type': file.contentType,
                    'content-length': fileData.length
                  }
                });
              }
            }
        env:
          version: ${{ steps.version.outputs.version }}
          is_tag: ${{ steps.version.outputs.is_tag }}
          release_name: ${{ steps.version.outputs.release_name }}
